# AI Development Context & Guidelines for This Repository

This document provides essential context for AI coding assistants working within this repository.

It outlines architectural principles, constraints, naming conventions, and deployment workflows for applications built on the **Atlantis Platform by 63Klabs** and deployed to AWS using serverless services.

All code and infrastructure generated by AI must follow these standards.

## 1. Purpose of This Repository

This repository contains the **application-specific code and infrastructure** for a serverless workload deployed on AWS.

It **does not** contain shared storage, networking, or pipeline infrastructure. Those are maintained separately by platform engineers.

Applications deployed via this repository follow the Golden Path for cloud development:

* Serverless-first architecture
* Event-driven design
* Modular stacks
* CI/CD pipelines per branch
* Infrastructure as Code (CloudFormation/SAM)

## 2. Platform Architecture & Guardrails

### 2.1 Atlantis Platform Templates (Do NOT Modify)

Shared templates for S3, DynamoDB, caching, networking (CloudFront/Route53), and pipelines come from:

* **Template Repo:** [https://github.com/63Klabs/atlantis-cfn-template-repo-for-serverless-deployments](https://github.com/63Klabs/atlantis-cfn-template-repo-for-serverless-deployments)
* **Configuration Repo:** [https://github.com/63Klabs/atlantis-cfn-configuration-repo-for-serverless-deployments](https://github.com/63Klabs/atlantis-cfn-configuration-repo-for-serverless-deployments)

**AI MUST NOT generate code that:**

* Modifies or duplicates these templates
* Rebuilds shared infrastructure (e.g., Route53, CloudFront, global logging policies, or cross-account roles)
* Creates account-level policies or resources meant for administrators

If extended permissions are needed:

* Add them as **Managed Policies** using
  * `CloudFormationSvcRoleIncludeManagedPolicyArns` or
  * `CodeBuildSvcRoleIncludeManagedPolicyArns`
* Do **not** edit the upstream templates.

## 3. Application Infrastructure Requirements

### 3.1 Separate Application Stacks Only

This repository **only** defines resources specific to this application.
It should *not* include:

* Shared storage buckets
* Global DynamoDB tables
* Account-level CloudFront or Route53 resources
* Organization-wide logging policies
* Any infrastructure maintained by central platform engineering

These belong in separate stacks controlled by administrators.

### 3.2 Naming Conventions (Required)

All resource names must follow:

```
Prefix-ProjectId-StageId-Resource
```

Where:

* **Prefix** = team or org identifier
* **ProjectId** = short identifier for the application
* **StageId** = test, beta/stage, prod
* **Resource** = Lambda, Topic, Queue, Table, etc.

**AI must respect these naming conventions in all generated example code, IAM roles, and infrastructure.**

These names will be provided to the CloudFormation template as parameters (Prefix, ProjectId, and StageId).

Correct example:

```
acme-person-api-test-GetPersonFunction
acme-schedules-prod-RefreshStepFunction
```

### 3.3 IAM Policies – Principle of Least Privilege

AI must follow these rules when generating IAM policies:

* **Never** use AWS managed policies such as `AWSLambdaFullAccess`, `AmazonS3FullAccess`, or `LambdaAll`.
* Always generate **tight, resource-scoped** permissions using ARNs that follow the naming convention.
* Policies must limit both **actions** and **resources**.

Correct:

```yaml
Action:
  - s3:PutObject
Resource:
  - !Sub arn:aws:s3:::${Prefix}-${ProjectId}-${StageId}-output/* 
```

Incorrect:

```yaml
Action: s3:*
Resource: "*"
```

## 4. Deployment Workflows & Branching Model

### 4.1 Branch-to-Environment Mapping

The following branches correspond to automated AWS Pipelines:

| Branch   | Environment | Stage       |
| -------- | ----------- | ----------- |
| **test** | TEST        | Test        |
| **beta** | PROD        | Beta        |
| **main** | PROD        | Prod        |

The use/naming of a beta or staging stage is up to the project owner. However, when deployed, it functions like a production environment.

Production environments (PROD) will have gradual deployments, longer log retention, and CloudWatch Alarms and Dashboards.

Non-production environments (TEST) will have immediate deployments, shorter log retention, more verbose logs, and fewer resources that could incur costs that are only needed at the production level (such as Alarms and Dashboards).

Merge sequence:

```
dev → test → beta → main
```

AI-generated instructions must follow this workflow.

### 4.2 Deployment Requirements

* Deployments are done **exclusively** through Atlantis Platform scripts.
* Scripts are centrally maintained and cloned internally.
* All builds run through the **organization-wide SAM Config repository**.
* Infrastructure changes must be deployed through the shared CI/CD pipeline—not manual deployments.
* Conditional logic may be built into the template and any environment variables based on the Deployment Environment (TEST/PROD)

AI suggestions **must not** recommend:

* Manual AWS Console deployments
* Creating custom pipeline YAML/JSON
* Editing CodePipeline templates
* Using Terraform, CDK, or serverless framework

## 5. Architectural Guidelines for AI-Generated Code

### 5.1 Prefer AWS Native Services

AI should suggest using AWS-managed services before writing custom code:

* EventBridge
* S3 event notifications
* SNS / SQS
* Step Functions
* DynamoDB
* API Gateway

Avoid large monolithic libraries; prefer event-driven, loosely coupled services.

### 5.2 Minimize Dependencies

AI must follow these rules:

* Do not package the AWS SDK (already available in Lambda)
* Favor native language libraries
  * Node.js built-in `crypto`
  * Python `hashlib`, `datetime`, `json`, etc.
* Avoid large third-party libraries unless absolutely necessary

### 5.3 Code Quality & Testing

AI-generated functions or methods should include:

* Unit test scaffolding
* Meaningful test cases
* Mocking of AWS SDK calls
* Clear separation of business logic from handler code

## 6. Security Requirements

### AI must always prioritize security by default:

* Use encryption at rest and in transit (KMS, HTTPS, S3 defaults)
* Enforce least privilege
* Ensure no secrets or credentials appear in code or logs
* Recommend Secrets Manager or SSM Parameter Store
* Avoid hardcoding environment variables that contain sensitive data
* Validate all inputs (API or event)
* Sanitize logs

## 7. What AI Tools Should Assume About This Repository

AI tools should assume:

* This application runs in a **serverless**, **event-driven** model
* Infrastructure is defined via CloudFormation/SAM
* CI/CD is fully automated
* Naming conventions and permissions are strictly enforced
* The application will be long-lived and require maintainability and cost efficiency

AI should **not** assume:

* Use of EC2, EKS, or persistent servers
* Unrestricted IAM roles
* Direct access to VPC-bound enterprise systems unless explicitly provided
* Experimental architectures that break platform guardrails

## 8. If AI Generates New Resources

It must:

* Fit within a modular architecture
* Follow naming conventions
* Respect the separation of stacks
* Avoid privileged or global resources
* Include appropriate IAM scoping
* Be consistent across test/beta/prod

## 9. Summary for AI (TL;DR)

* Use **serverless**, **event-driven**, **modular** architectures.
* Follow strict naming: `Prefix-ProjectId-StageId-*`.
* Apply **least privilege** IAM policies—never AWS-managed policies.
* Never modify Atlantis platform templates.
* Deploy only through pipeline scripts; no manual deployments.
* Keep dependencies small; use AWS-native services.
* Include unit tests for new functions.
* Keep shared infrastructure out of this repo.
